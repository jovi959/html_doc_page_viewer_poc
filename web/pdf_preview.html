<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>HTML Content Paginator with Logging</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /*
         * Defines the fixed size and appearance of our virtual pages.
         * The aspect ratio is similar to A4 paper.
         * 'overflow: hidden' is crucial for detecting when content exceeds the page boundary.
         */
        .page {
            width: 210mm;
            height: 297mm;
            /* UPDATED: Margins are now controlled by CSS variables */
            padding: var(--page-padding-top, 20mm) var(--page-padding-right, 20mm) var(--page-padding-bottom, 20mm) var(--page-padding-left, 20mm);
            background-color: white;
            box-shadow: 0 0 10px rgba(0,0,0,0.1);
            overflow: hidden;
            flex-shrink: 0; /* Prevents pages from shrinking in the flex container */
            position: relative; /* For potential future use with headers/footers */
            box-sizing: border-box; /* Ensures padding is included in the height/width */
            /* UPDATED: Font size is now a variable */
            font-size: var(--page-font-size, 16px);
            transition: padding 0.2s ease-in-out, font-size 0.2s ease-in-out;
        }

        /* UPDATED: Line height for paragraphs is now a variable */
        .page p {
            line-height: var(--page-line-height, 1.5);
        }

        /* NEW: Line height for list items is now a variable */
        .page ul li {
            line-height: var(--page-li-line-height, 1.5);
        }

        /* FIX: Restore list styles that are often removed by CSS resets like Tailwind's preflight. */
        .page ul {
            list-style: disc;
            padding-left: 2rem; /* Adjust as needed for indentation */
        }

        /* Styles for printing */
        @media print {
            body {
                background-color: white;
            }
            .page {
                box-shadow: none;
                margin: 0;
                width: auto;
                height: auto;
                page-break-after: always; /* Each .page div becomes a printed page */
            }
            #controls, #title-header, #log-container, #settings-toggle, #settings-panel {
                display: none; /* Hide all controls when printing */
            }
            #page-container {
                gap: 0 !important;
            }
        }

        /* NEW: Styles for the settings panel and toggle */
        #settings-toggle {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 1000;
            background-color: white;
            border-radius: 50%;
            padding: 12px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.2);
            cursor: pointer;
            transition: transform 0.3s ease;
        }
        #settings-toggle:hover {
            transform: scale(1.1) rotate(90deg);
        }

        #settings-panel {
            position: fixed;
            top: 0;
            right: -350px; /* Start off-screen */
            width: 320px;
            height: 100vh;
            background-color: white;
            z-index: 999;
            box-shadow: -5px 0 15px rgba(0,0,0,0.15);
            transition: right 0.4s cubic-bezier(0.25, 0.46, 0.45, 0.94);
            padding: 20px;
            padding-top: 80px; /* Space for the toggle button */
            overflow-y: auto;
        }

        #settings-panel.open {
            right: 0; /* Slide in */
        }

        .slider-group {
            margin-bottom: 1.5rem;
        }

        .slider-group label {
            display: flex;
            justify-content: space-between;
            font-weight: 500;
            color: #4A5568;
            margin-bottom: 0.5rem;
        }

        .slider-group input[type="range"] {
            -webkit-appearance: none;
            appearance: none;
            width: 100%;
            height: 8px;
            background: #E2E8F0;
            border-radius: 5px;
            outline: none;
        }

        .slider-group input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            background: #4299E1;
            cursor: pointer;
            border-radius: 50%;
        }

        .slider-group input[type="range"]::-moz-range-thumb {
            width: 20px;
            height: 20px;
            background: #4299E1;
            cursor: pointer;
            border-radius: 50%;
        }

        /* NEW: Hide controls when used in iframe or popup - only show settings */
        body.iframe-mode #controls,
        body.iframe-mode #title-header,
        body.iframe-mode #log-container,
        body.popup-mode #controls,
        body.popup-mode #title-header,
        body.popup-mode #log-container {
            display: none;
        }

        /* NEW: Floating controls container - settings at top right */
        #floating-controls {
            position: fixed;
            top: 10px;
            right: 10px;
            z-index: 1001;
        }

        /* Zoom controls at bottom right horizontally */
        #zoom-controls {
            position: fixed;
            bottom: 20px;
            right: 20px;
            z-index: 1001;
            display: flex;
            flex-direction: row;
            gap: 8px;
            align-items: center;
        }

        .floating-btn {
            width: 40px;
            height: 40px;
            background-color: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            box-shadow: 0 2px 12px rgba(0,0,0,0.15);
            transition: all 0.3s ease;
            border: 1px solid rgba(0,0,0,0.1);
        }

        .floating-btn:hover {
            transform: scale(1.1);
            background-color: rgba(255, 255, 255, 1);
            box-shadow: 0 4px 20px rgba(0,0,0,0.25);
        }

        .floating-btn:active {
            transform: scale(0.95);
        }

        .floating-display {
            background-color: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            padding: 6px 12px;
            border-radius: 20px;
            font-size: 12px;
            font-weight: 600;
            color: #4A5568;
            box-shadow: 0 2px 12px rgba(0,0,0,0.15);
            border: 1px solid rgba(0,0,0,0.1);
            min-width: 45px;
            text-align: center;
        }

        /* Settings panel positioning adjustment for iframe/popup modes */
        body.iframe-mode #settings-panel,
        body.popup-mode #settings-panel {
            top: 0;
        }
        
        body.iframe-mode #settings-panel.open,
        body.popup-mode #settings-panel.open {
            right: 0; /* Allow it to slide in when open */
        }

        body.iframe-mode,
        body.popup-mode {
            background-color: white;
        }

        body.iframe-mode .container,
        body.popup-mode .container {
            padding: 8px;
        }


    </style>
</head>
<body class="bg-gray-100 font-sans text-gray-800">

    <!-- Settings Button at Top Right -->
    <div id="floating-controls">
        <div id="settings-toggle" class="floating-btn" title="Settings">
            <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="3"></circle><path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z"></path></svg>
        </div>
    </div>

    <!-- Zoom Controls at Bottom Right -->
    <div id="zoom-controls">
        <!-- Pop Out Button (only show when in iframe) -->
        <div id="popout-btn" class="floating-btn" title="Pop Out" style="display: none;">
            <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 9V6a2 2 0 0 0-2-2H5a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h3"></path><path d="M16 3h5v5"></path><path d="M14 15h5l-5 5"></path><path d="M10 15l5-5"></path></svg>
        </div>
        
        <!-- Zoom Out Button -->
        <div id="zoom-out-btn" class="floating-btn" title="Zoom Out">
            <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="11" cy="11" r="8"></circle><path d="m21 21-4.35-4.35"></path><line x1="8" y1="11" x2="14" y2="11"></line></svg>
        </div>
        
        <!-- Zoom Level Display -->
        <div id="zoom-level" class="floating-display">100%</div>
        
        <!-- Zoom In Button -->
        <div id="zoom-in-btn" class="floating-btn" title="Zoom In">
            <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="11" cy="11" r="8"></circle><path d="m21 21-4.35-4.35"></path><line x1="11" y1="8" x2="11" y2="14"></line><line x1="8" y1="11" x2="14" y2="11"></line></svg>
        </div>
    </div>

    <!-- NEW: Settings Panel -->
    <div id="settings-panel">
        <h2 class="text-2xl font-bold text-gray-700 mb-6">Page Settings</h2>
        
        <div class="slider-group">
            <label for="margin-top-slider"><span>Top Margin</span><span id="margin-top-value">20mm</span></label>
            <input type="range" id="margin-top-slider" min="5" max="40" value="20">
        </div>
        <div class="slider-group">
            <label for="margin-bottom-slider"><span>Bottom Margin</span><span id="margin-bottom-value">20mm</span></label>
            <input type="range" id="margin-bottom-slider" min="5" max="40" value="20">
        </div>
        <div class="slider-group">
            <label for="margin-left-slider"><span>Left Margin</span><span id="margin-left-value">20mm</span></label>
            <input type="range" id="margin-left-slider" min="5" max="40" value="20">
        </div>
        <div class="slider-group">
            <label for="margin-right-slider"><span>Right Margin</span><span id="margin-right-value">20mm</span></label>
            <input type="range" id="margin-right-slider" min="5" max="40" value="20">
        </div>
        <hr class="my-6">
        <div class="slider-group">
            <label for="font-size-slider"><span>Font Size</span><span id="font-size-value">16px</span></label>
            <input type="range" id="font-size-slider" min="10" max="24" value="16">
        </div>
        <div class="slider-group">
            <label for="line-height-slider"><span>Line Height (p)</span><span id="line-height-value">1.5</span></label>
            <input type="range" id="line-height-slider" min="1.2" max="2.5" step="0.1" value="1.5">
        </div>

        <div class="slider-group">
            <label for="li-line-height-slider"><span>Line Height (li)</span><span id="li-line-height-value">1.5</span></label>
            <input type="range" id="li-line-height-slider" min="1.2" max="2.5" step="0.1" value="1.5">
        </div>
        
        <hr class="my-6">
        
        <!-- Pagination Status & Recovery -->
        <div class="pagination-status mb-4">
            <h3 class="text-lg font-semibold text-gray-700 mb-2">Pagination Status</h3>
            <div id="pagination-status-display" class="text-sm text-gray-600 mb-3">
                ✅ Normal
            </div>
            <button id="force-refresh-btn" class="w-full bg-blue-600 text-white px-4 py-2 rounded hover:bg-blue-700 transition-colors">
                🔄 Force Refresh Pagination
            </button>
            <button id="reset-margins-btn" class="w-full bg-yellow-600 text-white px-4 py-2 rounded hover:bg-yellow-700 transition-colors mt-2">
                ↩️ Reset to Default Margins
            </button>
        </div>

    </div>


    <div class="container mx-auto p-4 md:p-8">

        <!-- Header and Controls -->
        <div id="title-header" class="text-center mb-8">
            <h1 class="text-4xl font-bold text-gray-700">HTML Content Paginator</h1>
            <p class="text-lg text-gray-500 mt-2">Paste your HTML content below and watch it flow across pages.</p>
        </div>

        <div id="controls" class="max-w-4xl mx-auto bg-white p-6 rounded-lg shadow-md mb-8">
            <label for="html-input" class="block text-sm font-medium text-gray-700 mb-2">HTML Content:</label>
            <textarea id="html-input" class="w-full h-48 p-3 border border-gray-300 rounded-md focus:ring-2 focus:ring-blue-500 focus:border-blue-500 transition-shadow" placeholder="Paste your HTML here..."></textarea>
            <button id="paginate-btn" class="mt-4 w-full bg-blue-600 text-white font-bold py-3 px-4 rounded-md hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500 transition-colors">
                Paginate Content
            </button>
        </div>

        <!-- Container for the generated pages -->
        <div id="page-container" class="flex flex-wrap justify-center gap-8">
            <!-- Pages will be dynamically inserted here -->
        </div>

        <!-- Log Output -->
        <div id="log-container" class="max-w-4xl mx-auto bg-gray-800 text-white p-6 rounded-lg shadow-md my-8">
            <h3 class="text-lg font-semibold mb-2">Pagination Break Log (JSON)</h3>
            <pre id="log-output" class="text-sm whitespace-pre-wrap break-all bg-gray-900 p-4 rounded-md"></pre>
        </div>

    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // Check the mode - popup via URL parameter or iframe detection
            const urlParams = new URLSearchParams(window.location.search);
            const isPopupMode = urlParams.get('mode') === 'popup';
            const isIframeMode = window.self !== window.top;
            
            if (isIframeMode && !isPopupMode) {
                document.body.classList.add('iframe-mode');
                // Show pop-out button only in iframe mode
                document.getElementById('popout-btn').style.display = 'flex';
            } else if (isPopupMode) {
                document.body.classList.add('popup-mode');
                
                // Send ready message to opener
                if (window.opener && window.opener !== window) {
                    const readyMessage = {
                        type: 'popupReady'
                    };
                    window.opener.postMessage(JSON.stringify(readyMessage), '*');
                    console.log('Sent popup ready message to opener');
                }
            }
            const paginateBtn = document.getElementById('paginate-btn');
            const htmlInput = document.getElementById('html-input');
            const pageContainer = document.getElementById('page-container');
            const logOutput = document.getElementById('log-output');

            // --- NEW: Settings Panel Elements ---
            const settingsToggle = document.getElementById('settings-toggle');
            const settingsPanel = document.getElementById('settings-panel');
            const root = document.documentElement;

            // Margin Sliders
            const marginTopSlider = document.getElementById('margin-top-slider');
            const marginBottomSlider = document.getElementById('margin-bottom-slider');
            const marginLeftSlider = document.getElementById('margin-left-slider');
            const marginRightSlider = document.getElementById('margin-right-slider');
            const marginTopValue = document.getElementById('margin-top-value');
            const marginBottomValue = document.getElementById('margin-bottom-value');
            const marginLeftValue = document.getElementById('margin-left-value');
            const marginRightValue = document.getElementById('margin-right-value');

            // Font & Line Height Sliders
            const fontSizeSlider = document.getElementById('font-size-slider');
            const lineHeightSlider = document.getElementById('line-height-slider');
            const fontSizeValue = document.getElementById('font-size-value');
            const lineHeightValue = document.getElementById('line-height-value');
            const liLineHeightSlider = document.getElementById('li-line-height-slider');
            const liLineHeightValue = document.getElementById('li-line-height-value');


            let paginationLog = [];
            let currentPageNumber = 0;
            let paginateTimeout;
            let currentZoom = 1.0;

            // --- NEW: Event Listeners for Settings Panel ---
            settingsToggle.addEventListener('click', () => {
                settingsPanel.classList.toggle('open');
            });

            function setupSlider(slider, valueLabel, cssVariable, unit, isMargin = false) {
                slider.addEventListener('input', () => {
                    const value = slider.value;
                    valueLabel.textContent = `${value}${unit}`;
                    root.style.setProperty(cssVariable, `${value}${unit}`);
                    
                    // Enhanced validation for margin sliders
                    if (isMargin) {
                        validateMarginSettings();
                    }
                    
                    // Debounce pagination to prevent performance issues
                    clearTimeout(paginateTimeout);
                    paginateTimeout = setTimeout(paginateContent, 200);
                });
            }
            
            function validateMarginSettings() {
                const marginTop = parseFloat(marginTopSlider.value);
                const marginBottom = parseFloat(marginBottomSlider.value);
                const marginLeft = parseFloat(marginLeftSlider.value);
                const marginRight = parseFloat(marginRightSlider.value);
                
                const totalVerticalMargin = marginTop + marginBottom;
                const totalHorizontalMargin = marginLeft + marginRight;
                
                // Warn if margins are excessive
                if (totalVerticalMargin > 60) {
                    updatePaginationStatus('⚠️ High vertical margins may cause layout issues', 'warning');
                } else if (totalHorizontalMargin > 60) {
                    updatePaginationStatus('⚠️ High horizontal margins may cause layout issues', 'warning');
                } else {
                    updatePaginationStatus('✅ Normal', 'normal');
                }
            }
            
            function updatePaginationStatus(message, type) {
                const statusDisplay = document.getElementById('pagination-status-display');
                statusDisplay.textContent = message;
                statusDisplay.className = `text-sm mb-3 ${
                    type === 'error' ? 'text-red-600' : 
                    type === 'warning' ? 'text-yellow-600' : 
                    'text-gray-600'
                }`;
            }

            setupSlider(marginTopSlider, marginTopValue, '--page-padding-top', 'mm', true);
            setupSlider(marginBottomSlider, marginBottomValue, '--page-padding-bottom', 'mm', true);
            setupSlider(marginLeftSlider, marginLeftValue, '--page-padding-left', 'mm', true);
            setupSlider(marginRightSlider, marginRightValue, '--page-padding-right', 'mm', true);
            setupSlider(fontSizeSlider, fontSizeValue, '--page-font-size', 'px');
            setupSlider(lineHeightSlider, lineHeightValue, '--page-line-height', '');
            setupSlider(liLineHeightSlider, liLineHeightValue, '--page-li-line-height', '');
            
            // Recovery button event listeners
            document.getElementById('force-refresh-btn').addEventListener('click', () => {
                console.log('Manual force refresh triggered...');
                updatePaginationStatus('🔄 Refreshing...', 'normal');
                forceRefreshPagination();
            });
            
            document.getElementById('reset-margins-btn').addEventListener('click', () => {
                console.log('Resetting margins to defaults...');
                
                // Reset sliders to default values
                marginTopSlider.value = 20;
                marginBottomSlider.value = 20;
                marginLeftSlider.value = 20;
                marginRightSlider.value = 20;
                
                // Update displays
                marginTopValue.textContent = '20mm';
                marginBottomValue.textContent = '20mm';
                marginLeftValue.textContent = '20mm';
                marginRightValue.textContent = '20mm';
                
                // Update CSS variables
                root.style.setProperty('--page-padding-top', '20mm');
                root.style.setProperty('--page-padding-bottom', '20mm');
                root.style.setProperty('--page-padding-left', '20mm');
                root.style.setProperty('--page-padding-right', '20mm');
                
                updatePaginationStatus('✅ Margins reset to defaults', 'normal');
                
                // Force refresh pagination after reset
                setTimeout(() => {
                    forceRefreshPagination();
                }, 100);
            });

            // --- NEW: Floating Controls Event Listeners ---
            const zoomInBtn = document.getElementById('zoom-in-btn');
            const zoomOutBtn = document.getElementById('zoom-out-btn');
            const zoomLevel = document.getElementById('zoom-level');
            const popoutBtn = document.getElementById('popout-btn');

            function updateZoomDisplay() {
                zoomLevel.textContent = Math.round(currentZoom * 100) + '%';
            }

            function applyZoom() {
                pageContainer.style.transform = `scale(${currentZoom})`;
                pageContainer.style.transformOrigin = 'top left';
                updateZoomDisplay();
                
                // Adjust container width to prevent horizontal scrolling (like Flutter does)
                const containerWidth = 100 / currentZoom;
                pageContainer.style.width = `${containerWidth}%`;
                
                // Send zoom update to parent (Flutter)
                if (window.parent && window.parent !== window) {
                    const message = {
                        type: 'zoomChanged',
                        zoom: currentZoom
                    };
                    window.parent.postMessage(JSON.stringify(message), '*');
                }
                
                // Send zoom update to opener (popup mode)
                if (window.opener && window.opener !== window) {
                    const message = {
                        type: 'zoomChanged',
                        zoom: currentZoom
                    };
                    window.opener.postMessage(JSON.stringify(message), '*');
                }
            }

            zoomInBtn.addEventListener('click', () => {
                currentZoom = Math.min(currentZoom + 0.1, 3.0);
                applyZoom();
            });

            zoomOutBtn.addEventListener('click', () => {
                currentZoom = Math.max(currentZoom - 0.1, 0.5);
                applyZoom();
            });

            popoutBtn.addEventListener('click', () => {
                // Send pop-out request to parent (Flutter)
                if (window.parent && window.parent !== window) {
                    const message = {
                        type: 'requestPopout'
                    };
                    window.parent.postMessage(JSON.stringify(message), '*');
                }
            });

            // Initialize zoom display
            updateZoomDisplay();


            // Add some default content to demonstrate functionality
            htmlInput.value = `<h1>Complex Layout Test</h1>
<p>This paragraph includes <strong>bold text</strong> to test how different inline formatting is handled. The core idea remains the same: the script should accurately calculate the height and split content when it overflows. We're still using a long paragraph to ensure overflow happens.</p>
<h2>Key Features (Bullet Points)</h2>
<ul>
    <li>This is the first bullet point. It adds a different kind of vertical rhythm to the page.</li>
    <li>Second bullet point, also with some text.</li>
    <li>Let's make this third bullet point a bit longer to see how it wraps and contributes to the overall height of the list element. The entire list should be treated as a single block.</li>
    <li>A fourth, shorter point.</li>
</ul>
<p>Now, let's test spacing with multiple line breaks.<br><br>This text appears after two line breaks. This tests if the script correctly measures the extra vertical space introduced by the <strong>br</strong> tags. Line breaks are often tricky for layout calculation engines.</p>
<p>Here is another paragraph, just for good measure. We want to ensure that after all the complex content above, the pagination continues to work as expected. This paragraph will likely be the one that gets split across the first and second pages. We need to add enough text here to make sure it is long enough to overflow. Lorem ipsum dolor sit amet, consectetur adipiscing elit. Sed non risus. Suspendisse lectus tortor, dignissim sit amet, adipiscing nec, ultricies sed, dolor. Cras elementum ultrices diam. Maecenas ligula massa, varius a, semper congue, euismod non, mi. Proin porttitor, orci nec nonummy molestie, enim est eleifend mi, non fermentum diam nisl sit amet erat.</p>
<p>This final paragraph should hopefully land on the second page, demonstrating that the remainder of the content was successfully carried over after the split.</p>
<h2>Extremely Long List To Test Splitting</h2>
<ul>
    <li>List Item 1</li>
    <li>List Item 2</li>
    <li>List Item 3</li>
    <li>List Item 4</li>
    <li>List Item 5</li>
    <li>List Item 6</li>
    <li>List Item 7</li>
    <li>List Item 8</li>
    <li>List Item 9</li>
    <li>List Item 10</li>
    <li>List Item 11</li>
    <li>List Item 12</li>
    <li>List Item 13</li>
    <li>List Item 14</li>
    <li>List Item 15</li>
    <li>List Item 16</li>
    <li>List Item 17</li>
    <li>List Item 18</li>
    <li>List Item 19</li>
    <li>List Item 20</li>
    <li>List Item 21</li>
    <li>List Item 22</li>
    <li>List Item 23</li>
    <li>List Item 24</li>
    <li>List Item 25</li>
    <li>List Item 26</li>
    <li>List Item 27</li>
    <li>List Item 28</li>
    <li>List Item 29</li>
    <li>List Item 30</li>
    <li>List Item 31</li>
    <li>List Item 32</li>
    <li>List Item 33</li>
    <li>List Item 34</li>
    <li>List Item 35</li>
    <li>List Item 36</li>
    <li>List Item 37</li>
    <li>List Item 38</li>
    <li>List Item 39</li>
    <li>List Item 40</li>
</ul>
<h2>Complex Formatting Test</h2>
<p>This is the final test paragraph, designed to be extremely long to ensure it splits across at least one page break, probably landing on the third page. It contains <strong>bold text</strong>, <em>italicized words</em>, and <u>underlined sections</u> to check if the splitting logic can preserve inline formatting. We also include <mark>highlighted text</mark> which is another common formatting type. The key challenge is that the splitting function can no longer simply use <code>textContent</code>. It must be DOM-aware, understanding that it might need to split a text node that is a child of another element, like a <strong> tag. If the split happens <em><u>inside a doubly-nested format</u></em>, both tags must be correctly closed in the first part and reopened in the second. This is a significantly more complex problem than splitting plain text. Let's add a lot more content here to guarantee an overflow. Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod <mark>tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam,</mark> quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.</p>
`;


            paginateBtn.addEventListener('click', paginateContent);

            /**
             * The main function to handle the pagination logic using height calculation.
             */
            function paginateContent() {
                console.log('--- Starting Pagination ---');
                
                try {
                    // Store current zoom and reset to 100% for calculation
                    const currentZoom = getCurrentZoomLevel();
                    console.log(`Current zoom: ${currentZoom}, temporarily resetting to 100% for calculation`);
                    pageContainer.style.transform = 'scale(1)';
                    pageContainer.style.transformOrigin = 'top left';
                    
                    // Clear previous state
                    pageContainer.innerHTML = '';
                    logOutput.textContent = '';
                    paginationLog = [];
                    currentPageNumber = 0;

                    // Get logical page height at 100% zoom
                    const pageHeight = getValidatedPageHeight();
                    if (pageHeight === 0) {
                        throw new Error("Could not determine valid page height");
                    }
                    
                    // Validate input content
                    const htmlContent = (htmlInput.value || '').trim();
                    if (!htmlContent) {
                        console.warn("No content to paginate");
                        createNewPage(); // Create at least one empty page
                        return;
                    }
                    
                    // Create source container with validation
                    const sourceContainer = document.createElement('div');
                    try {
                        sourceContainer.innerHTML = htmlContent;
                    } catch (e) {
                        console.error("Invalid HTML content:", e);
                        throw new Error("Could not parse HTML content");
                    }
                    
                    const sourceNodes = Array.from(sourceContainer.childNodes).filter(node => 
                        node.nodeType === Node.ELEMENT_NODE || 
                        (node.nodeType === Node.TEXT_NODE && node.textContent.trim())
                    );
                    
                    if (sourceNodes.length === 0) {
                        console.warn("No valid nodes found to paginate");
                        createNewPage(); // Create at least one empty page
                        return;
                    }

                    let currentPage = createNewPage();
                    let currentHeight = 0;
                    let lastNodeOnPage = null;
                    let originalHtmlContent = htmlContent;
                    let processedHtmlLength = 0;
                    let iterationCount = 0;
                    const maxIterations = sourceNodes.length * 3; // Safety limit
                    
                    console.log(`Available page height: ${pageHeight}px`);
                    console.log(`Processing ${sourceNodes.length} nodes`);


                for (let i = 0; i < sourceNodes.length; i++) {
                    const node = sourceNodes[i];
                    if (node.nodeType !== Node.ELEMENT_NODE) {
                        continue;
                    }

                    console.log(`%cProcessing Node: <${node.tagName}>`, 'color: blue; font-weight: bold;');
                    let nodeToProcess = node.cloneNode(true);
                    let currentNodeHtmlIndex = processedHtmlLength;
                    
                    let nodeProcessingAttempts = 0;
                    const maxNodeAttempts = 10; // Prevent infinite loops on a single node
                    
                    while (nodeToProcess && nodeProcessingAttempts < maxNodeAttempts) {
                        iterationCount++;
                        nodeProcessingAttempts++;
                        
                        // Safety check to prevent infinite loops
                        if (iterationCount > maxIterations) {
                            console.error(`Maximum iterations reached (${maxIterations}). Aborting pagination to prevent infinite loop.`);
                            console.error(`Current node: <${node.tagName}>, Processing attempts: ${nodeProcessingAttempts}`);
                            break;
                        }
                        const nodeHeight = calculateNodeHeight(nodeToProcess, currentPage);
                        console.log(`Calculated node height: ${nodeHeight}px. Current filled height: ${currentHeight}px.`);
                        
                        // Additional validation for node height
                        if (nodeHeight === 0 && nodeToProcess.textContent.trim()) {
                            console.warn(`Node has content but zero height. Forcing minimal height.`);
                            // Try to add it anyway, might be a measurement issue
                        }

                        if (currentHeight + nodeHeight <= pageHeight) {
                            // The node fits on the current page
                            console.log('...Node fits. Adding to current page.');
                            try {
                                currentPage.appendChild(nodeToProcess);
                                currentHeight += nodeHeight;
                                lastNodeOnPage = nodeToProcess;
                                nodeToProcess = null; // Mark as processed
                            } catch (error) {
                                console.error("Error appending node to page:", error);
                                nodeToProcess = null; // Skip this node to prevent infinite loop
                            }
                        } else {
                            // The node overflows
                            const overflowAmount = (currentHeight + nodeHeight) - pageHeight;
                            console.log(`%c...Node overflows by approximately ${overflowAmount.toFixed(2)}px.`, 'color: orange;');
                            
                            if (canSplitNode(nodeToProcess)) {
                                const remainingHeight = pageHeight - currentHeight;
                                console.log(`Node is splittable. Attempting to split with remaining height: ${remainingHeight}px`);
                                
                                // Ensure we have enough space to split
                                if (remainingHeight < 20) {
                                    console.log('Remaining height too small for splitting. Creating new page.');
                                    const nextNode = nodeToProcess;
                                    logPageBoundary(lastNodeOnPage, nextNode, currentPageNumber, 'Clean Boundary', currentNodeHtmlIndex);
                                    currentPage = createNewPage();
                                    currentHeight = 0;
                                    lastNodeOnPage = null;
                                    continue;
                                }
                                
                                const { fittingPart, remainingPart } = splitNodeByHeight(nodeToProcess, remainingHeight, currentPage);
                                
                                if (fittingPart) {
                                    console.log('...Fitting part found. Adding to current page.');
                                    try {
                                        currentPage.appendChild(fittingPart);
                                        const fittingHeight = calculateNodeHeight(fittingPart, currentPage);
                                        currentHeight += fittingHeight;
                                    } catch (error) {
                                        console.error("Error appending fitting part:", error);
                                    }
                                } else {
                                    console.log('...No fitting part could be created.');
                                }
                                
                                console.log('--- Creating New Page ---');
                                // Log the split boundary with approximate HTML index
                                const splitIndexEstimate = currentNodeHtmlIndex + Math.floor(node.outerHTML.length * 0.5); // Rough estimate
                                logPageBoundary(lastNodeOnPage, remainingPart, currentPageNumber - 1, 'Split Boundary', splitIndexEstimate);
                                currentPage = createNewPage();
                                currentHeight = 0;
                                lastNodeOnPage = null;
                                nodeToProcess = remainingPart; 
                                if (!nodeToProcess) {
                                     console.log('No remaining part to process.');
                                }

                            } else {
                                console.log('Node is not splittable.');
                                if (currentHeight === 0) {
                                    console.warn('...Element is too large for a single page. Forcing it onto the page.');
                                    try {
                                        currentPage.appendChild(nodeToProcess);
                                        nodeToProcess = null;
                                    } catch (error) {
                                        console.error("Error forcing large element onto page:", error);
                                        nodeToProcess = null; // Skip to prevent infinite loop
                                    }
                                } else {
                                    console.log('--- Creating New Page ---');
                                    // Log the clean boundary (no split, just page transition)
                                    const nextNode = nodeToProcess;
                                    logPageBoundary(lastNodeOnPage, nextNode, currentPageNumber, 'Clean Boundary', currentNodeHtmlIndex);
                                    currentPage = createNewPage();
                                    currentHeight = 0;
                                    lastNodeOnPage = null;
                                }
                            }
                        }
                    }
                    
                    // Check if we failed to process a node
                    if (nodeProcessingAttempts >= maxNodeAttempts) {
                        console.error(`Failed to process node after ${maxNodeAttempts} attempts. Skipping node:`, node);
                    }
                    
                    // Track processed HTML length for next iteration
                    try {
                        processedHtmlLength += node.outerHTML.length;
                    } catch (error) {
                        console.warn("Could not track HTML length for node:", error);
                    }
                }
                
                // Final validation
                if (pageContainer.children.length === 0) {
                    console.warn("No pages were created. Creating empty page as fallback.");
                    createNewPage();
                }
                
                // Simple validation - no complex warning logic needed
                const totalPages = pageContainer.children.length;
                console.log(`Pagination complete: ${totalPages} pages created`);
                
                if (totalPages === 0) {
                    console.warn("No pages were created, creating empty page");
                    createNewPage();
                }
                
                // Apply zoom AFTER pagination calculation is complete
                if (currentZoom !== 1) {
                    console.log(`Applying zoom ${currentZoom} after pagination calculation`);
                    pageContainer.style.transform = `scale(${currentZoom})`;
                    pageContainer.style.transformOrigin = 'top left';
                    updateZoomDisplay();
                }
                
                console.log('--- Pagination Complete ---');
                console.log(`Total iterations: ${iterationCount}, Pages created: ${pageContainer.children.length}`);

                const logJson = JSON.stringify(paginationLog, null, 2);
                console.log('--- Pagination Log ---');
                console.log(logJson);
                logOutput.textContent = logJson;
                
                } catch (error) {
                    console.error('Critical pagination error:', error);
                    
                    // Restore zoom even on error
                    if (currentZoom !== 1) {
                        pageContainer.style.transform = `scale(${currentZoom})`;
                        pageContainer.style.transformOrigin = 'top left';
                    }
                    
                    // Emergency fallback - create a single page with original content
                    try {
                        pageContainer.innerHTML = '';
                        const emergencyPage = createNewPage();
                        emergencyPage.innerHTML = `
                            <div style="color: red; border: 2px solid red; padding: 10px; margin: 10px;">
                                <h3>Pagination Error</h3>
                                <p>An error occurred during pagination. Original content displayed below:</p>
                            </div>
                            <div>${htmlInput.value || ''}</div>
                        `;
                        
                        // Set error message in log
                        logOutput.textContent = JSON.stringify([{
                            type: 'Error',
                            message: 'Pagination failed: ' + error.message,
                            timestamp: new Date().toISOString()
                        }], null, 2);
                        
                    } catch (emergencyError) {
                        console.error('Emergency fallback failed:', emergencyError);
                        pageContainer.innerHTML = '<div style="color: red;">Critical Error: Unable to display content</div>';
                        logOutput.textContent = 'Critical Error: Unable to display content';
                    }
                }
            }
            
            function getPageHeight() {
                // ALWAYS measure at 100% zoom (no transform) to get the logical page height
                const measurementPage = document.createElement('div');
                measurementPage.className = 'page';
                measurementPage.style.position = 'absolute';
                measurementPage.style.left = '-9999px';
                measurementPage.style.top = '-9999px';
                measurementPage.style.visibility = 'hidden';
                // NO transform applied - measure at 100% zoom

                document.body.appendChild(measurementPage);
                
                const style = window.getComputedStyle(measurementPage);
                const paddingTop = parseFloat(style.paddingTop) || 0;
                const paddingBottom = parseFloat(style.paddingBottom) || 0;
                const marginTop = parseFloat(style.marginTop) || 0;
                const marginBottom = parseFloat(style.marginBottom) || 0;
                
                const height = measurementPage.clientHeight;
                document.body.removeChild(measurementPage);
                
                // Calculate available content height accounting for padding and margins
                let availableHeight = height - paddingTop - paddingBottom - marginTop - marginBottom;
                
                console.log(`Logical page height (100% zoom): ${availableHeight}px`);
                
                // Ensure we have a reasonable minimum height
                const minHeight = 200;
                return Math.max(availableHeight, minHeight);
            }
            
            function getValidatedPageHeight() {
                return getPageHeight();
            }
            
            function getCurrentZoomLevel() {
                // Extract zoom level from the page container's transform
                const transform = pageContainer.style.transform;
                if (transform && transform.includes('scale(')) {
                    const scaleMatch = transform.match(/scale\(([^)]+)\)/);
                    if (scaleMatch) {
                        return parseFloat(scaleMatch[1]) || 1;
                    }
                }
                return 1; // Default zoom level
            }

            function calculateNodeHeight(node, page) {
                if (!node || !page) {
                    console.error("calculateNodeHeight: Invalid node or page");
                    return 0;
                }
                
                try {
                    // ALWAYS measure at 100% zoom (no transform) to get logical height
                    const tempNode = node.cloneNode(true);
                    tempNode.style.visibility = 'hidden';
                    tempNode.style.position = 'static';
                    // NO transform applied - measure at 100% zoom
                    
                    page.appendChild(tempNode);
                    tempNode.offsetHeight; // Force layout
                    
                    const style = window.getComputedStyle(tempNode);
                    const marginTop = parseFloat(style.marginTop) || 0;
                    const marginBottom = parseFloat(style.marginBottom) || 0;
                    const elementHeight = tempNode.getBoundingClientRect().height || 0;

                    page.removeChild(tempNode);

                    const totalHeight = marginTop + elementHeight + marginBottom;
                    
                    // Validate the calculated height
                    if (isNaN(totalHeight) || totalHeight < 0 || totalHeight > 10000) {
                        console.warn(`Suspicious node height calculated: ${totalHeight}px for node:`, node.tagName);
                        return 0;
                    }
                    
                    return totalHeight;
                } catch (error) {
                    console.error("Error calculating node height:", error, node);
                    return 0;
                }
            }

            function createNewPage() {
                currentPageNumber++;
                const newPage = document.createElement('div');
                newPage.className = 'page';
                pageContainer.appendChild(newPage);
                return newPage;
            }

            function logPageBoundary(previousNode, nextNode, pageNumber, boundaryType, splitIndex = null) {
                const getNodeInfo = (node, isEnding = false) => {
                    if (!node) return { type: 'none', content: '' };
                    
                    if (node.tagName === 'P') {
                        const text = node.textContent.trim();
                        if (isEnding) {
                            // For page endings, show the end of the content (truncate from front)
                            return {
                                type: 'Paragraph',
                                content: text.length > 50 ? '...' + text.substring(text.length - 50) : text
                            };
                        } else {
                            // For page starts, show the beginning (truncate from end)
                            return {
                                type: 'Paragraph',
                                content: text.length > 50 ? text.substring(0, 50) + '...' : text
                            };
                        }
                    } else if (node.tagName === 'UL') {
                        const firstItem = node.querySelector('li')?.textContent.trim() || '';
                        const lastItem = Array.from(node.querySelectorAll('li')).pop()?.textContent.trim() || '';
                        return {
                            type: 'List',
                            content: firstItem.length > 30 ? firstItem.substring(0, 30) + '...' : firstItem,
                            firstItem: firstItem.length > 30 ? firstItem.substring(0, 30) + '...' : firstItem,
                            lastItem: lastItem.length > 30 ? '...' + lastItem.substring(lastItem.length - 30) : lastItem
                        };
                    } else if (node.tagName && node.tagName.match(/^H[1-6]$/)) {
                        return {
                            type: `Heading ${node.tagName.charAt(1)}`,
                            content: node.textContent.trim()
                        };
                    } else {
                        const text = node.textContent ? node.textContent.trim() : '';
                        if (isEnding) {
                            return {
                                type: node.tagName || 'Unknown',
                                content: text.length > 50 ? '...' + text.substring(text.length - 50) : text
                            };
                        } else {
                            return {
                                type: node.tagName || 'Unknown',
                                content: text.length > 50 ? text.substring(0, 50) + '...' : text
                            };
                        }
                    }
                };

                const prevInfo = getNodeInfo(previousNode, true); // true = isEnding
                const nextInfo = getNodeInfo(nextNode, false); // false = isStarting

                const logEntry = {
                    type: boundaryType,
                    pageBreakAtEndOf: pageNumber,
                    endsWith: prevInfo,
                    nextPageStartsWith: nextInfo,
                    timestamp: new Date().toISOString()
                };

                // Add split index if provided
                if (splitIndex !== null) {
                    logEntry.splitIndex = splitIndex;
                }

                paginationLog.push(logEntry);

                console.log(`%c${boundaryType} Page Boundary:`, 'color: #2563EB; font-weight: bold;');
                console.log(`  > Page ${pageNumber} ends with: ${prevInfo.type} - "${prevInfo.content}"`);
                console.log(`  > Page ${pageNumber + 1} starts with: ${nextInfo.type} - "${nextInfo.content}"`);
                if (splitIndex !== null) {
                    console.log(`  > Split occurs at HTML index: ~${splitIndex}`);
                }
            }

            function canSplitNode(node) {
                if (node.nodeType !== Node.ELEMENT_NODE) return false;
                const tagName = node.tagName;
                return (tagName === 'P' && node.textContent.trim().length > 0) || (tagName === 'UL' && node.children.length > 0);
            }

            function splitNodeByHeight(node, availableHeight, page) {
                console.log(`[split] Trying to fit content into available height: ${availableHeight}px`);
                
                if (node.tagName === 'P') {
                    return splitParagraphNodeByDom(node, availableHeight, page);
                } else if (node.tagName === 'UL') {
                    return splitListNode(node, availableHeight, page);
                }

                return { fittingPart: null, remainingPart: node };
            }

            function splitParagraphNodeByDom(node, availableHeight, page) {
                const originalNode = node.cloneNode(true);
                const fittingPart = node.cloneNode(false);
                const remainingPart = node.cloneNode(false);
                let splitOccurred = false;
                let characterIndex = 0;
                let splitIndex = -1;

                function processChildren(originalParent, fittingParent, remainingParent) {
                    for (const child of Array.from(originalParent.childNodes)) {
                        if (splitOccurred) {
                            remainingParent.appendChild(child.cloneNode(true));
                            continue;
                        }

                        if (child.nodeType === Node.TEXT_NODE) {
                            const words = child.textContent.split(/(\s+)/);
                            for (const word of words) {
                                if (splitOccurred) {
                                    remainingParent.appendChild(document.createTextNode(word));
                                    continue;
                                }

                                const tempTextNode = document.createTextNode(word);
                                fittingParent.appendChild(tempTextNode);
                                
                                if (calculateNodeHeight(fittingPart, page) > availableHeight) {
                                    if(!splitOccurred) {
                                        splitIndex = characterIndex;
                                    }
                                    splitOccurred = true;
                                    fittingParent.removeChild(tempTextNode);
                                    remainingParent.appendChild(document.createTextNode(word));
                                } else {
                                     characterIndex += word.length;
                                }
                            }
                        } else if (child.nodeType === Node.ELEMENT_NODE) {
                            const newFittingChild = child.cloneNode(false);
                            const newRemainingChild = child.cloneNode(false);
                            
                            fittingParent.appendChild(newFittingChild);
                            processChildren(child, newFittingChild, newRemainingChild);
                            
                            if (newRemainingChild.hasChildNodes()) {
                                remainingParent.appendChild(newRemainingChild);
                            }
                            
                            if (!newFittingChild.hasChildNodes() && !newFittingChild.textContent) {
                                fittingParent.removeChild(newFittingChild);
                            }
                        }
                    }
                }

                processChildren(originalNode, fittingPart, remainingPart);

                if (!splitOccurred) {
                    return { fittingPart: originalNode, remainingPart: null };
                }

                if (fittingPart.textContent.trim().length === 0) {
                     console.log('%c[split] Could not fit even one word.', 'color: red;');
                    return { fittingPart: null, remainingPart: originalNode };
                }

                console.log(`%cPAGE BREAK in Paragraph:`, 'color: #8A2BE2; font-weight: bold;');
                console.log(`  > Split occurs at character index: ~${splitIndex} (in original paragraph text)`);

                return { fittingPart, remainingPart: remainingPart.hasChildNodes() ? remainingPart : null };
            }


            function splitListNode(node, availableHeight, page) {
                try {
                    const originalContent = node.cloneNode(true);
                    const listItems = Array.from(originalContent.children);
                    
                    if (listItems.length === 0) {
                        console.warn('List node has no items to split');
                        return { fittingPart: null, remainingPart: originalContent };
                    }
                    
                    const fittingPart = node.cloneNode(false); // Create an empty <ul>

                    // Validate available height
                    if (availableHeight < 10) {
                        console.warn('Available height too small for list splitting');
                        return { fittingPart: null, remainingPart: originalContent };
                    }

                    for (let i = listItems.length; i > 0; i--) {
                        try {
                            fittingPart.innerHTML = '';
                            for (let j = 0; j < i; j++) {
                                fittingPart.appendChild(listItems[j].cloneNode(true));
                            }

                            const tempHeight = calculateNodeHeight(fittingPart, page);
                            console.log(`[split-ul] Testing with ${i} list items. Calculated height: ${tempHeight}px`);

                            if (tempHeight <= availableHeight && tempHeight > 0) {
                                const remainingItems = listItems.slice(i);
                                if (remainingItems.length === 0) {
                                    return { fittingPart: originalContent, remainingPart: null };
                                }

                                const remainingPart = originalContent.cloneNode(false);
                                remainingItems.forEach(item => remainingPart.appendChild(item.cloneNode(true)));

                                console.log(`%c[split-ul] Found a fit!`, 'color: green;');

                                let splitIndex = 0;
                                for (let j = 0; j < i; j++) {
                                    try {
                                        splitIndex += listItems[j].outerHTML.length;
                                    } catch (error) {
                                        console.warn('Error calculating split index for list item:', error);
                                    }
                                }

                                console.log(`%cPAGE BREAK in List:`, 'color: #8A2BE2; font-weight: bold;');
                                console.log(`  > Split occurs at character index: ~${splitIndex} (relative to <ul> content)`);
                                
                                return { fittingPart, remainingPart };
                            }
                        } catch (itemError) {
                            console.warn(`Error testing list item ${i}:`, itemError);
                            continue; // Try next item count
                        }
                    }

                    console.log('%c[split-ul] Could not fit even one list item.', 'color: red;');
                    return { fittingPart: null, remainingPart: originalContent };
                    
                } catch (error) {
                    console.error('Error in splitListNode:', error);
                    return { fittingPart: null, remainingPart: node };
                }
            }

            /**
             * NEW: Publicly accessible function to update the content and re-paginate.
             * You can call this from the browser's developer console, e.g.:
             * updateContentAndRepaginate('<h2>New Title</h2><p>This is my new content.</p>')
             * @param {string} htmlString The raw HTML content to render.
             */
            window.updateContentAndRepaginate = function(htmlString) {
                if (typeof htmlString !== 'string') {
                    console.error('updateContentAndRepaginate expects a string argument.');
                    return;
                }
                htmlInput.value = htmlString;
                
                // Force a complete refresh to reset any problematic state
                forceRefreshPagination();
            };
            
            /**
             * Force refresh pagination with state reset
             */
            function forceRefreshPagination() {
                console.log('Force refreshing pagination with state reset...');
                
                // Clear all cached state and reset variables
                paginationLog = [];
                currentPageNumber = 0;
                pageContainer.innerHTML = '';
                logOutput.textContent = '';
                
                // Force a small delay to allow any pending DOM updates to complete
                setTimeout(() => {
                    try {
                        // Validate page setup before proceeding
                        const testHeight = getValidatedPageHeight();
                        console.log(`Post-refresh page height validation: ${testHeight}px`);
                        
                        if (testHeight < 150) {
                            console.warn('Page height seems too small after refresh, attempting correction...');
                            // Reset any extreme CSS that might be affecting layout
                            document.documentElement.style.setProperty('--page-margin-top', '20mm');
                            document.documentElement.style.setProperty('--page-margin-bottom', '20mm');
                            document.documentElement.style.setProperty('--page-margin-left', '20mm');
                            document.documentElement.style.setProperty('--page-margin-right', '20mm');
                        }
                        
                        paginateContent();
                        
                    } catch (error) {
                        console.error('Error during force refresh:', error);
                        // Emergency fallback
                        createEmergencyPage();
                    }
                }, 100);
            }
            
            /**
             * Create emergency fallback page when pagination completely fails
             */
            function createEmergencyPage() {
                console.warn('Creating emergency fallback page...');
                pageContainer.innerHTML = '';
                const emergencyPage = document.createElement('div');
                emergencyPage.className = 'page';
                emergencyPage.innerHTML = `
                    <div style="color: red; border: 2px solid red; padding: 10px; margin: 10px; background: #ffe6e6;">
                        <h3>⚠️ Pagination Recovery Mode</h3>
                        <p>The pagination system encountered an issue, likely due to extreme margin settings.</p>
                        <p><strong>To fix:</strong> Adjust margins to reasonable values and try updating content again.</p>
                        <hr style="margin: 10px 0;">
                        <div style="border: 1px solid #ccc; padding: 10px; background: white; color: black; max-height: 400px; overflow-y: auto;">
                            ${htmlInput.value || '<p>No content available</p>'}
                        </div>
                    </div>
                `;
                pageContainer.appendChild(emergencyPage);
                
                logOutput.textContent = JSON.stringify([{
                    type: 'Emergency Recovery',
                    message: 'Pagination failed, displaying content in emergency mode',
                    timestamp: new Date().toISOString(),
                    suggestion: 'Adjust margin settings and try again'
                }], null, 2);
            }

            // Initially paginate the default content
            paginateContent();

            // --- NEW: Message handling for Flutter communication ---
            window.addEventListener('message', function(event) {
                try {
                    const data = JSON.parse(event.data);
                    console.log('Received message:', data);
                    
                    if (data.action === 'updateContent') {
                        console.log('Updating content with:', data.html.substring(0, 100) + '...');
                        // Update the HTML content and re-paginate
                        htmlInput.value = data.html;
                        paginateContent();
                    } else if (data.action === 'setZoom') {
                        console.log('Setting zoom to:', data.zoom);
                        // Update internal zoom level - no need to repaginate, just apply visual zoom
                        currentZoom = data.zoom;
                        pageContainer.style.transform = `scale(${currentZoom})`;
                        pageContainer.style.transformOrigin = 'top left';
                        updateZoomDisplay();
                        
                        // Adjust container width to prevent horizontal scrolling
                        const containerWidth = 100 / currentZoom;
                        pageContainer.style.width = `${containerWidth}%`;
                    }
                } catch (e) {
                    // Ignore non-JSON messages
                    console.log('Received non-JSON message:', event.data);
                }
            });

            // --- NEW: Send pagination data to parent window or opener ---
            function sendPaginationDataToParent() {
                const message = {
                    type: 'paginationData',
                    payload: paginationLog
                };
                
                // Send to iframe parent
                if (window.parent && window.parent !== window) {
                    window.parent.postMessage(JSON.stringify(message), '*');
                }
                
                // Send to popup opener
                if (window.opener && window.opener !== window) {
                    window.opener.postMessage(JSON.stringify(message), '*');
                }
            }

            // Override the original paginateContent to also send data to parent
            const originalPaginateContent = paginateContent;
            paginateContent = function() {
                originalPaginateContent();
                // Send pagination data after a short delay to ensure it's updated
                setTimeout(sendPaginationDataToParent, 100);
            };
        });
    </script>
</body>
</html>

