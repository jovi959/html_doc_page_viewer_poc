<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>HTML Content Paginator with Logging</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /*
         * Defines the fixed size and appearance of our virtual pages.
         * The aspect ratio is similar to A4 paper.
         * 'overflow: hidden' is crucial for detecting when content exceeds the page boundary.
         */
        .page {
            width: 210mm;
            height: 297mm;
            /* UPDATED: Margins are now controlled by CSS variables */
            padding: var(--page-padding-top, 20mm) var(--page-padding-right, 20mm) var(--page-padding-bottom, 20mm) var(--page-padding-left, 20mm);
            background-color: white;
            box-shadow: 0 0 10px rgba(0,0,0,0.1);
            overflow: hidden;
            flex-shrink: 0; /* Prevents pages from shrinking in the flex container */
            position: relative; /* For potential future use with headers/footers */
            box-sizing: border-box; /* Ensures padding is included in the height/width */
            /* UPDATED: Font size is now a variable */
            font-size: var(--page-font-size, 16px);
            transition: padding 0.2s ease-in-out, font-size 0.2s ease-in-out;
        }

        /* UPDATED: Line height for paragraphs is now a variable */
        .page p {
            line-height: var(--page-line-height, 1.5);
        }

        /* NEW: Line height for list items is now a variable */
        .page ul li {
            line-height: var(--page-li-line-height, 1.5);
        }

        /* FIX: Restore list styles that are often removed by CSS resets like Tailwind's preflight. */
        .page ul {
            list-style: disc;
            padding-left: 2rem; /* Adjust as needed for indentation */
        }

        /* Styles for printing */
        @media print {
            body {
                background-color: white;
            }
            .page {
                box-shadow: none;
                margin: 0;
                width: auto;
                height: auto;
                page-break-after: always; /* Each .page div becomes a printed page */
            }
            #controls, #title-header, #log-container, #settings-toggle, #settings-panel {
                display: none; /* Hide all controls when printing */
            }
            #page-container {
                gap: 0 !important;
            }
        }

        /* NEW: Styles for the settings panel and toggle */
        #settings-toggle {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 1000;
            background-color: white;
            border-radius: 50%;
            padding: 12px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.2);
            cursor: pointer;
            transition: transform 0.3s ease;
        }
        #settings-toggle:hover {
            transform: scale(1.1) rotate(90deg);
        }

        #settings-panel {
            position: fixed;
            top: 0;
            right: -350px; /* Start off-screen */
            width: 320px;
            height: 100vh;
            background-color: white;
            z-index: 999;
            box-shadow: -5px 0 15px rgba(0,0,0,0.15);
            transition: right 0.4s cubic-bezier(0.25, 0.46, 0.45, 0.94);
            padding: 20px;
            padding-top: 80px; /* Space for the toggle button */
            overflow-y: auto;
        }

        #settings-panel.open {
            right: 0; /* Slide in */
        }

        .slider-group {
            margin-bottom: 1.5rem;
        }

        .slider-group label {
            display: flex;
            justify-content: space-between;
            font-weight: 500;
            color: #4A5568;
            margin-bottom: 0.5rem;
        }

        .slider-group input[type="range"] {
            -webkit-appearance: none;
            appearance: none;
            width: 100%;
            height: 8px;
            background: #E2E8F0;
            border-radius: 5px;
            outline: none;
        }

        .slider-group input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            background: #4299E1;
            cursor: pointer;
            border-radius: 50%;
        }

        .slider-group input[type="range"]::-moz-range-thumb {
            width: 20px;
            height: 20px;
            background: #4299E1;
            cursor: pointer;
            border-radius: 50%;
        }

        /* NEW: Hide controls when used in iframe or popup - only show settings */
        body.iframe-mode #controls,
        body.iframe-mode #title-header,
        body.iframe-mode #log-container,
        body.popup-mode #controls,
        body.popup-mode #title-header,
        body.popup-mode #log-container {
            display: none;
        }

        /* Always show settings in iframe and popup mode, but position differently */
        body.iframe-mode #settings-toggle,
        body.popup-mode #settings-toggle {
            position: fixed;
            top: 10px;
            right: 10px;
            z-index: 1001;
            background-color: rgba(255, 255, 255, 0.9);
            backdrop-filter: blur(5px);
        }

        body.iframe-mode,
        body.popup-mode {
            background-color: white;
        }

        body.iframe-mode .container,
        body.popup-mode .container {
            padding: 8px;
        }


    </style>
</head>
<body class="bg-gray-100 font-sans text-gray-800">

    <!-- NEW: Settings Toggle Button -->
    <div id="settings-toggle">
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-settings"><circle cx="12" cy="12" r="3"></circle><path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z"></path></svg>
    </div>

    <!-- NEW: Settings Panel -->
    <div id="settings-panel">
        <h2 class="text-2xl font-bold text-gray-700 mb-6">Page Settings</h2>
        
        <div class="slider-group">
            <label for="margin-top-slider"><span>Top Margin</span><span id="margin-top-value">20mm</span></label>
            <input type="range" id="margin-top-slider" min="5" max="40" value="20">
        </div>
        <div class="slider-group">
            <label for="margin-bottom-slider"><span>Bottom Margin</span><span id="margin-bottom-value">20mm</span></label>
            <input type="range" id="margin-bottom-slider" min="5" max="40" value="20">
        </div>
        <div class="slider-group">
            <label for="margin-left-slider"><span>Left Margin</span><span id="margin-left-value">20mm</span></label>
            <input type="range" id="margin-left-slider" min="5" max="40" value="20">
        </div>
        <div class="slider-group">
            <label for="margin-right-slider"><span>Right Margin</span><span id="margin-right-value">20mm</span></label>
            <input type="range" id="margin-right-slider" min="5" max="40" value="20">
        </div>
        <hr class="my-6">
        <div class="slider-group">
            <label for="font-size-slider"><span>Font Size</span><span id="font-size-value">16px</span></label>
            <input type="range" id="font-size-slider" min="10" max="24" value="16">
        </div>
        <div class="slider-group">
            <label for="line-height-slider"><span>Line Height (p)</span><span id="line-height-value">1.5</span></label>
            <input type="range" id="line-height-slider" min="1.2" max="2.5" step="0.1" value="1.5">
        </div>

        <div class="slider-group">
            <label for="li-line-height-slider"><span>Line Height (li)</span><span id="li-line-height-value">1.5</span></label>
            <input type="range" id="li-line-height-slider" min="1.2" max="2.5" step="0.1" value="1.5">
        </div>

    </div>


    <div class="container mx-auto p-4 md:p-8">

        <!-- Header and Controls -->
        <div id="title-header" class="text-center mb-8">
            <h1 class="text-4xl font-bold text-gray-700">HTML Content Paginator</h1>
            <p class="text-lg text-gray-500 mt-2">Paste your HTML content below and watch it flow across pages.</p>
        </div>

        <div id="controls" class="max-w-4xl mx-auto bg-white p-6 rounded-lg shadow-md mb-8">
            <label for="html-input" class="block text-sm font-medium text-gray-700 mb-2">HTML Content:</label>
            <textarea id="html-input" class="w-full h-48 p-3 border border-gray-300 rounded-md focus:ring-2 focus:ring-blue-500 focus:border-blue-500 transition-shadow" placeholder="Paste your HTML here..."></textarea>
            <button id="paginate-btn" class="mt-4 w-full bg-blue-600 text-white font-bold py-3 px-4 rounded-md hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500 transition-colors">
                Paginate Content
            </button>
        </div>

        <!-- Container for the generated pages -->
        <div id="page-container" class="flex flex-wrap justify-center gap-8">
            <!-- Pages will be dynamically inserted here -->
        </div>

        <!-- Log Output -->
        <div id="log-container" class="max-w-4xl mx-auto bg-gray-800 text-white p-6 rounded-lg shadow-md my-8">
            <h3 class="text-lg font-semibold mb-2">Pagination Break Log (JSON)</h3>
            <pre id="log-output" class="text-sm whitespace-pre-wrap break-all bg-gray-900 p-4 rounded-md"></pre>
        </div>

    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // Check the mode - popup via URL parameter or iframe detection
            const urlParams = new URLSearchParams(window.location.search);
            const isPopupMode = urlParams.get('mode') === 'popup';
            const isIframeMode = window.self !== window.top;
            
            if (isIframeMode && !isPopupMode) {
                document.body.classList.add('iframe-mode');
            } else if (isPopupMode) {
                document.body.classList.add('popup-mode');
                
                // Send ready message to opener
                if (window.opener && window.opener !== window) {
                    const readyMessage = {
                        type: 'popupReady'
                    };
                    window.opener.postMessage(JSON.stringify(readyMessage), '*');
                    console.log('Sent popup ready message to opener');
                }
            }
            const paginateBtn = document.getElementById('paginate-btn');
            const htmlInput = document.getElementById('html-input');
            const pageContainer = document.getElementById('page-container');
            const logOutput = document.getElementById('log-output');

            // --- NEW: Settings Panel Elements ---
            const settingsToggle = document.getElementById('settings-toggle');
            const settingsPanel = document.getElementById('settings-panel');
            const root = document.documentElement;

            // Margin Sliders
            const marginTopSlider = document.getElementById('margin-top-slider');
            const marginBottomSlider = document.getElementById('margin-bottom-slider');
            const marginLeftSlider = document.getElementById('margin-left-slider');
            const marginRightSlider = document.getElementById('margin-right-slider');
            const marginTopValue = document.getElementById('margin-top-value');
            const marginBottomValue = document.getElementById('margin-bottom-value');
            const marginLeftValue = document.getElementById('margin-left-value');
            const marginRightValue = document.getElementById('margin-right-value');

            // Font & Line Height Sliders
            const fontSizeSlider = document.getElementById('font-size-slider');
            const lineHeightSlider = document.getElementById('line-height-slider');
            const fontSizeValue = document.getElementById('font-size-value');
            const lineHeightValue = document.getElementById('line-height-value');
            const liLineHeightSlider = document.getElementById('li-line-height-slider');
            const liLineHeightValue = document.getElementById('li-line-height-value');


            let paginationLog = [];
            let currentPageNumber = 0;
            let paginateTimeout;

            // --- NEW: Event Listeners for Settings Panel ---
            settingsToggle.addEventListener('click', () => {
                settingsPanel.classList.toggle('open');
            });

            function setupSlider(slider, valueLabel, cssVariable, unit) {
                slider.addEventListener('input', () => {
                    const value = slider.value;
                    valueLabel.textContent = `${value}${unit}`;
                    root.style.setProperty(cssVariable, `${value}${unit}`);
                    
                    // Debounce pagination to prevent performance issues
                    clearTimeout(paginateTimeout);
                    paginateTimeout = setTimeout(paginateContent, 200);
                });
            }

            setupSlider(marginTopSlider, marginTopValue, '--page-padding-top', 'mm');
            setupSlider(marginBottomSlider, marginBottomValue, '--page-padding-bottom', 'mm');
            setupSlider(marginLeftSlider, marginLeftValue, '--page-padding-left', 'mm');
            setupSlider(marginRightSlider, marginRightValue, '--page-padding-right', 'mm');
            setupSlider(fontSizeSlider, fontSizeValue, '--page-font-size', 'px');
            setupSlider(lineHeightSlider, lineHeightValue, '--page-line-height', '');
            setupSlider(liLineHeightSlider, liLineHeightValue, '--page-li-line-height', '');


            // Add some default content to demonstrate functionality
            htmlInput.value = `<h1>Complex Layout Test</h1>
<p>This paragraph includes <strong>bold text</strong> to test how different inline formatting is handled. The core idea remains the same: the script should accurately calculate the height and split content when it overflows. We're still using a long paragraph to ensure overflow happens.</p>
<h2>Key Features (Bullet Points)</h2>
<ul>
    <li>This is the first bullet point. It adds a different kind of vertical rhythm to the page.</li>
    <li>Second bullet point, also with some text.</li>
    <li>Let's make this third bullet point a bit longer to see how it wraps and contributes to the overall height of the list element. The entire list should be treated as a single block.</li>
    <li>A fourth, shorter point.</li>
</ul>
<p>Now, let's test spacing with multiple line breaks.<br><br>This text appears after two line breaks. This tests if the script correctly measures the extra vertical space introduced by the <strong>br</strong> tags. Line breaks are often tricky for layout calculation engines.</p>
<p>Here is another paragraph, just for good measure. We want to ensure that after all the complex content above, the pagination continues to work as expected. This paragraph will likely be the one that gets split across the first and second pages. We need to add enough text here to make sure it is long enough to overflow. Lorem ipsum dolor sit amet, consectetur adipiscing elit. Sed non risus. Suspendisse lectus tortor, dignissim sit amet, adipiscing nec, ultricies sed, dolor. Cras elementum ultrices diam. Maecenas ligula massa, varius a, semper congue, euismod non, mi. Proin porttitor, orci nec nonummy molestie, enim est eleifend mi, non fermentum diam nisl sit amet erat.</p>
<p>This final paragraph should hopefully land on the second page, demonstrating that the remainder of the content was successfully carried over after the split.</p>
<h2>Extremely Long List To Test Splitting</h2>
<ul>
    <li>List Item 1</li>
    <li>List Item 2</li>
    <li>List Item 3</li>
    <li>List Item 4</li>
    <li>List Item 5</li>
    <li>List Item 6</li>
    <li>List Item 7</li>
    <li>List Item 8</li>
    <li>List Item 9</li>
    <li>List Item 10</li>
    <li>List Item 11</li>
    <li>List Item 12</li>
    <li>List Item 13</li>
    <li>List Item 14</li>
    <li>List Item 15</li>
    <li>List Item 16</li>
    <li>List Item 17</li>
    <li>List Item 18</li>
    <li>List Item 19</li>
    <li>List Item 20</li>
    <li>List Item 21</li>
    <li>List Item 22</li>
    <li>List Item 23</li>
    <li>List Item 24</li>
    <li>List Item 25</li>
    <li>List Item 26</li>
    <li>List Item 27</li>
    <li>List Item 28</li>
    <li>List Item 29</li>
    <li>List Item 30</li>
    <li>List Item 31</li>
    <li>List Item 32</li>
    <li>List Item 33</li>
    <li>List Item 34</li>
    <li>List Item 35</li>
    <li>List Item 36</li>
    <li>List Item 37</li>
    <li>List Item 38</li>
    <li>List Item 39</li>
    <li>List Item 40</li>
</ul>
<h2>Complex Formatting Test</h2>
<p>This is the final test paragraph, designed to be extremely long to ensure it splits across at least one page break, probably landing on the third page. It contains <strong>bold text</strong>, <em>italicized words</em>, and <u>underlined sections</u> to check if the splitting logic can preserve inline formatting. We also include <mark>highlighted text</mark> which is another common formatting type. The key challenge is that the splitting function can no longer simply use <code>textContent</code>. It must be DOM-aware, understanding that it might need to split a text node that is a child of another element, like a <strong> tag. If the split happens <em><u>inside a doubly-nested format</u></em>, both tags must be correctly closed in the first part and reopened in the second. This is a significantly more complex problem than splitting plain text. Let's add a lot more content here to guarantee an overflow. Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod <mark>tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam,</mark> quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.</p>
`;


            paginateBtn.addEventListener('click', paginateContent);

            /**
             * The main function to handle the pagination logic using height calculation.
             */
            function paginateContent() {
                console.log('--- Starting Pagination ---');
                pageContainer.innerHTML = '';
                logOutput.textContent = '';
                
                paginationLog = [];
                currentPageNumber = 0;

                const pageHeight = getPageHeight();

                if (pageHeight === 0) {
                    console.error("Critical Error: Could not determine page height. Aborting pagination.");
                    return;
                }
                
                const sourceContainer = document.createElement('div');
                sourceContainer.innerHTML = htmlInput.value;
                const sourceNodes = Array.from(sourceContainer.childNodes);
                if (sourceNodes.length === 0) return;

                let currentPage = createNewPage();
                let currentHeight = 0;
                let lastNodeOnPage = null;
                let originalHtmlContent = htmlInput.value;
                let processedHtmlLength = 0;
                console.log(`Available page height: ${pageHeight}px`);


                for (let i = 0; i < sourceNodes.length; i++) {
                    const node = sourceNodes[i];
                    if (node.nodeType !== Node.ELEMENT_NODE) {
                        continue;
                    }

                    console.log(`%cProcessing Node: <${node.tagName}>`, 'color: blue; font-weight: bold;');
                    let nodeToProcess = node.cloneNode(true);
                    let currentNodeHtmlIndex = processedHtmlLength;
                    
                    while (nodeToProcess) {
                        const nodeHeight = calculateNodeHeight(nodeToProcess, currentPage);
                        console.log(`Calculated node height: ${nodeHeight}px. Current filled height: ${currentHeight}px.`);


                        if (currentHeight + nodeHeight <= pageHeight) {
                            // The node fits on the current page
                            console.log('...Node fits. Adding to current page.');
                            currentPage.appendChild(nodeToProcess);
                            currentHeight += nodeHeight;
                            lastNodeOnPage = nodeToProcess;
                            nodeToProcess = null; // Mark as processed
                        } else {
                            // The node overflows
                            const overflowAmount = (currentHeight + nodeHeight) - pageHeight;
                            console.log(`%c...Node overflows by approximately ${overflowAmount.toFixed(2)}px.`, 'color: orange;');
                            
                            if (canSplitNode(nodeToProcess)) {
                                const remainingHeight = pageHeight - currentHeight;
                                console.log(`Node is splittable. Attempting to split with remaining height: ${remainingHeight}px`);
                                const { fittingPart, remainingPart } = splitNodeByHeight(nodeToProcess, remainingHeight, currentPage);
                                
                                if (fittingPart) {
                                    console.log('...Fitting part found. Adding to current page.');
                                    currentPage.appendChild(fittingPart);
                                    currentHeight += calculateNodeHeight(fittingPart, currentPage);
                                } else {
                                    console.log('...No fitting part could be created.');
                                }
                                
                                console.log('--- Creating New Page ---');
                                // Log the split boundary with approximate HTML index
                                const splitIndexEstimate = currentNodeHtmlIndex + Math.floor(node.outerHTML.length * 0.5); // Rough estimate
                                logPageBoundary(lastNodeOnPage, remainingPart, currentPageNumber - 1, 'Split Boundary', splitIndexEstimate);
                                currentPage = createNewPage();
                                currentHeight = 0;
                                lastNodeOnPage = null;
                                nodeToProcess = remainingPart; 
                                if (!nodeToProcess) {
                                     console.log('No remaining part to process.');
                                }

                            } else {
                                console.log('Node is not splittable.');
                                if (currentHeight === 0) {
                                    console.warn('...Element is too large for a single page. Forcing it onto the page.');
                                    currentPage.appendChild(nodeToProcess);
                                    nodeToProcess = null;
                                } else {
                                    console.log('--- Creating New Page ---');
                                    // Log the clean boundary (no split, just page transition)
                                    const nextNode = nodeToProcess;
                                    logPageBoundary(lastNodeOnPage, nextNode, currentPageNumber, 'Clean Boundary', currentNodeHtmlIndex);
                                    currentPage = createNewPage();
                                    currentHeight = 0;
                                    lastNodeOnPage = null;
                                }
                            }
                        }
                    }
                    // Track processed HTML length for next iteration
                    processedHtmlLength += node.outerHTML.length;
                }
                console.log('--- Pagination Complete ---');

                const logJson = JSON.stringify(paginationLog, null, 2);
                console.log('--- Pagination Log ---');
                console.log(logJson);
                logOutput.textContent = logJson;
            }
            
            function getPageHeight() {
                const measurementPage = document.createElement('div');
                measurementPage.className = 'page';
                measurementPage.style.position = 'absolute';
                measurementPage.style.left = '-9999px';
                measurementPage.style.top = '-9999px';
                measurementPage.style.visibility = 'hidden';

                document.body.appendChild(measurementPage);
                
                const style = window.getComputedStyle(measurementPage);
                // We need the clientHeight which is the inner height (content + padding)
                // Then we subtract the padding to get the pure content height available.
                const paddingTop = parseFloat(style.paddingTop);
                const paddingBottom = parseFloat(style.paddingBottom);
                const height = measurementPage.clientHeight;

                document.body.removeChild(measurementPage);
                
                // This correctly returns the available content area height
                return height - paddingTop - paddingBottom;
            }
            
            function calculateNodeHeight(node, page) {
                const tempNode = node.cloneNode(true);
                tempNode.style.visibility = 'hidden';
                page.appendChild(tempNode);

                const style = window.getComputedStyle(tempNode);
                const marginTop = parseFloat(style.marginTop);
                const marginBottom = parseFloat(style.marginBottom);
                // getBoundingClientRect().height includes padding and border, which is what we want
                const elementHeight = tempNode.getBoundingClientRect().height;

                page.removeChild(tempNode);

                const totalHeight = marginTop + elementHeight + marginBottom;
                return totalHeight;
            }

            function createNewPage() {
                currentPageNumber++;
                const newPage = document.createElement('div');
                newPage.className = 'page';
                pageContainer.appendChild(newPage);
                return newPage;
            }

            function logPageBoundary(previousNode, nextNode, pageNumber, boundaryType, splitIndex = null) {
                const getNodeInfo = (node, isEnding = false) => {
                    if (!node) return { type: 'none', content: '' };
                    
                    if (node.tagName === 'P') {
                        const text = node.textContent.trim();
                        if (isEnding) {
                            // For page endings, show the end of the content (truncate from front)
                            return {
                                type: 'Paragraph',
                                content: text.length > 50 ? '...' + text.substring(text.length - 50) : text
                            };
                        } else {
                            // For page starts, show the beginning (truncate from end)
                            return {
                                type: 'Paragraph',
                                content: text.length > 50 ? text.substring(0, 50) + '...' : text
                            };
                        }
                    } else if (node.tagName === 'UL') {
                        const firstItem = node.querySelector('li')?.textContent.trim() || '';
                        const lastItem = Array.from(node.querySelectorAll('li')).pop()?.textContent.trim() || '';
                        return {
                            type: 'List',
                            content: firstItem.length > 30 ? firstItem.substring(0, 30) + '...' : firstItem,
                            firstItem: firstItem.length > 30 ? firstItem.substring(0, 30) + '...' : firstItem,
                            lastItem: lastItem.length > 30 ? '...' + lastItem.substring(lastItem.length - 30) : lastItem
                        };
                    } else if (node.tagName && node.tagName.match(/^H[1-6]$/)) {
                        return {
                            type: `Heading ${node.tagName.charAt(1)}`,
                            content: node.textContent.trim()
                        };
                    } else {
                        const text = node.textContent ? node.textContent.trim() : '';
                        if (isEnding) {
                            return {
                                type: node.tagName || 'Unknown',
                                content: text.length > 50 ? '...' + text.substring(text.length - 50) : text
                            };
                        } else {
                            return {
                                type: node.tagName || 'Unknown',
                                content: text.length > 50 ? text.substring(0, 50) + '...' : text
                            };
                        }
                    }
                };

                const prevInfo = getNodeInfo(previousNode, true); // true = isEnding
                const nextInfo = getNodeInfo(nextNode, false); // false = isStarting

                const logEntry = {
                    type: boundaryType,
                    pageBreakAtEndOf: pageNumber,
                    endsWith: prevInfo,
                    nextPageStartsWith: nextInfo,
                    timestamp: new Date().toISOString()
                };

                // Add split index if provided
                if (splitIndex !== null) {
                    logEntry.splitIndex = splitIndex;
                }

                paginationLog.push(logEntry);

                console.log(`%c${boundaryType} Page Boundary:`, 'color: #2563EB; font-weight: bold;');
                console.log(`  > Page ${pageNumber} ends with: ${prevInfo.type} - "${prevInfo.content}"`);
                console.log(`  > Page ${pageNumber + 1} starts with: ${nextInfo.type} - "${nextInfo.content}"`);
                if (splitIndex !== null) {
                    console.log(`  > Split occurs at HTML index: ~${splitIndex}`);
                }
            }

            function canSplitNode(node) {
                if (node.nodeType !== Node.ELEMENT_NODE) return false;
                const tagName = node.tagName;
                return (tagName === 'P' && node.textContent.trim().length > 0) || (tagName === 'UL' && node.children.length > 0);
            }

            function splitNodeByHeight(node, availableHeight, page) {
                console.log(`[split] Trying to fit content into available height: ${availableHeight}px`);
                
                if (node.tagName === 'P') {
                    return splitParagraphNodeByDom(node, availableHeight, page);
                } else if (node.tagName === 'UL') {
                    return splitListNode(node, availableHeight, page);
                }

                return { fittingPart: null, remainingPart: node };
            }

            function splitParagraphNodeByDom(node, availableHeight, page) {
                const originalNode = node.cloneNode(true);
                const fittingPart = node.cloneNode(false);
                const remainingPart = node.cloneNode(false);
                let splitOccurred = false;
                let characterIndex = 0;
                let splitIndex = -1;

                function processChildren(originalParent, fittingParent, remainingParent) {
                    for (const child of Array.from(originalParent.childNodes)) {
                        if (splitOccurred) {
                            remainingParent.appendChild(child.cloneNode(true));
                            continue;
                        }

                        if (child.nodeType === Node.TEXT_NODE) {
                            const words = child.textContent.split(/(\s+)/);
                            for (const word of words) {
                                if (splitOccurred) {
                                    remainingParent.appendChild(document.createTextNode(word));
                                    continue;
                                }

                                const tempTextNode = document.createTextNode(word);
                                fittingParent.appendChild(tempTextNode);
                                
                                if (calculateNodeHeight(fittingPart, page) > availableHeight) {
                                    if(!splitOccurred) {
                                        splitIndex = characterIndex;
                                    }
                                    splitOccurred = true;
                                    fittingParent.removeChild(tempTextNode);
                                    remainingParent.appendChild(document.createTextNode(word));
                                } else {
                                     characterIndex += word.length;
                                }
                            }
                        } else if (child.nodeType === Node.ELEMENT_NODE) {
                            const newFittingChild = child.cloneNode(false);
                            const newRemainingChild = child.cloneNode(false);
                            
                            fittingParent.appendChild(newFittingChild);
                            processChildren(child, newFittingChild, newRemainingChild);
                            
                            if (newRemainingChild.hasChildNodes()) {
                                remainingParent.appendChild(newRemainingChild);
                            }
                            
                            if (!newFittingChild.hasChildNodes() && !newFittingChild.textContent) {
                                fittingParent.removeChild(newFittingChild);
                            }
                        }
                    }
                }

                processChildren(originalNode, fittingPart, remainingPart);

                if (!splitOccurred) {
                    return { fittingPart: originalNode, remainingPart: null };
                }

                if (fittingPart.textContent.trim().length === 0) {
                     console.log('%c[split] Could not fit even one word.', 'color: red;');
                    return { fittingPart: null, remainingPart: originalNode };
                }

                console.log(`%cPAGE BREAK in Paragraph:`, 'color: #8A2BE2; font-weight: bold;');
                console.log(`  > Split occurs at character index: ~${splitIndex} (in original paragraph text)`);

                return { fittingPart, remainingPart: remainingPart.hasChildNodes() ? remainingPart : null };
            }


            function splitListNode(node, availableHeight, page) {
                const originalContent = node.cloneNode(true);
                const listItems = Array.from(originalContent.children);
                const fittingPart = node.cloneNode(false); // Create an empty <ul>

                for (let i = listItems.length; i > 0; i--) {
                    fittingPart.innerHTML = '';
                    for (let j = 0; j < i; j++) {
                        fittingPart.appendChild(listItems[j].cloneNode(true));
                    }

                    const tempHeight = calculateNodeHeight(fittingPart, page);
                    console.log(`[split-ul] Testing with ${i} list items. Calculated height: ${tempHeight}px`);

                    if (tempHeight <= availableHeight) {
                        const remainingItems = listItems.slice(i);
                        if (remainingItems.length === 0) {
                            return { fittingPart: originalContent, remainingPart: null };
                        }

                        const remainingPart = originalContent.cloneNode(false);
                        remainingItems.forEach(item => remainingPart.appendChild(item.cloneNode(true)));

                        console.log(`%c[split-ul] Found a fit!`, 'color: green;');

                        let splitIndex = 0;
                        for (let j = 0; j < i; j++) {
                            splitIndex += listItems[j].outerHTML.length;
                        }

                        console.log(`%cPAGE BREAK in List:`, 'color: #8A2BE2; font-weight: bold;');
                        console.log(`  > Split occurs at character index: ~${splitIndex} (relative to <ul> content)`);
                        
                        return { fittingPart, remainingPart };
                    }
                }

                console.log('%c[split-ul] Could not fit even one list item.', 'color: red;');
                return { fittingPart: null, remainingPart: originalContent };
            }

            /**
             * NEW: Publicly accessible function to update the content and re-paginate.
             * You can call this from the browser's developer console, e.g.:
             * updateContentAndRepaginate('<h2>New Title</h2><p>This is my new content.</p>')
             * @param {string} htmlString The raw HTML content to render.
             */
            window.updateContentAndRepaginate = function(htmlString) {
                if (typeof htmlString !== 'string') {
                    console.error('updateContentAndRepaginate expects a string argument.');
                    return;
                }
                htmlInput.value = htmlString;
                paginateContent();
            }

            // Initially paginate the default content
            paginateContent();

            // --- NEW: Message handling for Flutter communication ---
            window.addEventListener('message', function(event) {
                try {
                    const data = JSON.parse(event.data);
                    console.log('Received message:', data);
                    
                    if (data.action === 'updateContent') {
                        console.log('Updating content with:', data.html.substring(0, 100) + '...');
                        // Update the HTML content and re-paginate
                        htmlInput.value = data.html;
                        paginateContent();
                    } else if (data.action === 'setZoom') {
                        console.log('Setting zoom to:', data.zoom);
                        // Apply zoom to the page container
                        const zoomLevel = data.zoom;
                        pageContainer.style.transform = `scale(${zoomLevel})`;
                        pageContainer.style.transformOrigin = 'top left';
                        
                        // Adjust container width to prevent horizontal scrolling
                        const containerWidth = 100 / zoomLevel;
                        pageContainer.style.width = `${containerWidth}%`;
                    }
                } catch (e) {
                    // Ignore non-JSON messages
                    console.log('Received non-JSON message:', event.data);
                }
            });

            // --- NEW: Send pagination data to parent window or opener ---
            function sendPaginationDataToParent() {
                const message = {
                    type: 'paginationData',
                    payload: paginationLog
                };
                
                // Send to iframe parent
                if (window.parent && window.parent !== window) {
                    window.parent.postMessage(JSON.stringify(message), '*');
                }
                
                // Send to popup opener
                if (window.opener && window.opener !== window) {
                    window.opener.postMessage(JSON.stringify(message), '*');
                }
            }

            // Override the original paginateContent to also send data to parent
            const originalPaginateContent = paginateContent;
            paginateContent = function() {
                originalPaginateContent();
                // Send pagination data after a short delay to ensure it's updated
                setTimeout(sendPaginationDataToParent, 100);
            };
        });
    </script>
</body>
</html>

